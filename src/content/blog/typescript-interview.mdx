---
title: Top 10 TypeScript Interview Questions
description: Must to TypeScript concepts.
date: 2024-02-10
thumbnail: '/images/undraw/image-10.png'
tags:
  - typescript
---

## 1. What are Conditional Types in TypeScript and when would you use them?

**Answer:**

Conditional types let you expressÂ **type-level logic**. They work like anÂ `if/else`Â for types.

**Syntax:**

```javascript
T extends U ? X : Y
```

- IfÂ `T`Â is assignable toÂ `U`, the type resolves toÂ `X`.
- Otherwise, it resolves toÂ `Y`.

**Example:**

```javascript
type IsString<T> = T extends string ? "yes" : "no";

type A = IsString<string>;   // "yes"
type B = IsString<number>;   // "no"
```

**Real-world usage:**

**Conditional types help buildÂ flexible APIs**

```javascript
function getValue<T>(value: T): T extends () => infer R ? R : T {
  if (typeof value === "function") {
    return (value as any)() // returns function result
  }
  return value as any;
}

const a = getValue(42);         // number
const b = getValue(() => "Hi"); // string
```

ğŸ‘‰ This allows functions toÂ **adapt based on input**Â type.

## 2. ExplainÂ `infer`Â in TypeScript with an example.

**Answer:**

`infer`Â allows you toÂ **capture a type inside a conditional type**.

**Example: Extracting Promise Result**

```javascript
type Awaited<T> = T extends Promise<infer U> ? U : T;

type A = Awaited<Promise<number>>; // number
type B = Awaited<string>;          // string
```

Here,Â `infer U`Â tells TypeScript:Â *â€œTry to infer the typeÂ `U`Â inside the Promise.â€*

**Real-world usage:**

You often seeÂ `infer`Â inÂ **utility types**Â likeÂ `ReturnType<T>`Â orÂ `Parameters<T>`.

```javascript
type MyReturnType<T extends (...args: any[]) => any> =
  T extends (...args: any[]) => infer R ? R : never;

function greet() { return "hello"; }

type GreetReturn = MyReturnType<typeof greet>; // "hello"
```

## 3. What is Type Narrowing, and how is it different from Type Assertions?

**Answer:**

- **Type Narrowing**: TypeScript automatically understands more specific types during control flow.
- **Type Assertion**: You manually tell TypeScript the type (`as Type`).

**Example of Narrowing:**

```javascript
function printId(id: string | number) {
  if (typeof id === "string") {
    console.log(id.toUpperCase()); // narrowed to string
  } else {
    console.log(id.toFixed(2));    // narrowed to number
  }
}
```

**Example of Assertion:**

```
let someValue: unknown = "hello";
let strLength: number = (someValue as string).length;
```

ğŸ‘‰Â **Difference**: Narrowing is safe (compiler-checked), while assertions are manual and can be unsafe.

## 4. What are Mapped Types? Give an advanced example.

**Answer:**

Mapped types allow you toÂ **transform existing types**.

**Example: Making properties optional**

```
type Partial<T> = { [P in keyof T]?: T[P] };
```

**Advanced Example: Immutable Type**

```javascript
type Immutable<T> = {
  readonly [K in keyof T]: Immutable<T[K]>;
};

type User = {
  name: string;
  address: { city: string; zip: number };
};

type ReadonlyUser = Immutable<User>;
```

Now,Â `ReadonlyUser`Â makes all nested properties deeplyÂ `readonly`.

## 5. ExplainÂ `never`,Â `unknown`, andÂ `any`.

- **`any`**: Opts out of type checking (unsafe).
- **`unknown`**: Safer alternative; you must check the type before using.
- **`never`**: Represents impossible values. Often used in exhaustive checks.

**Example:**

```javascript
function exhaustive(x: "a" | "b"): number {
  switch (x) {
    case "a": return 1;
    case "b": return 2;
    default:
      const check: never = x; // ensures no missing cases
      return check;
  }
}
```

## 6. How does TypeScript handle Union vs Intersection types?
**Answer:**
- **Union (`|`)**: Value can beÂ *one of many*.

```javascript
type A = string | number;
let x: A = "hello"; // ok
x = 42;             // ok
```

- **Intersection (`&`)**: Value must satisfyÂ *all at once*.

```javascript
type B = { name: string } & { age: number };
const person: B = { name: "Alex", age: 30 }; // must have both
```

ğŸ‘‰ Common interview trick: ask candidates what happens if you do:

```
type C = string & number; // never
```

## 7. What are Utility Types in TypeScript? Give examples.

**Answer:**

TypeScript ships with built-inÂ **utility types**Â that manipulate existing types.

- `Partial<T>`Â â†’ all properties optional
- `Required<T>`Â â†’ all properties required
- `Pick<T, K>`Â â†’ select specific properties
- `Omit<T, K>`Â â†’ exclude specific properties
- `ReturnType<T>`Â â†’ function return type

**Example:**

```javascript
type User = { id: number; name: string; email?: string };

type UserPreview = Pick<User, "id" | "name">;
```

## 8. Explain Variance in TypeScript.

**Answer:**

Variance describes how subtyping works inÂ **generic types**.

- **Covariant**Â â†’ Safe to substitute subtype.
- **Contravariant**Â â†’ Safe to substitute supertype.
- **Invariant**Â â†’ No substitution allowed.

**Example:**

```javascript
type Fn<T> = (arg: T) => void;

let fn1: Fn<string> = (s: string) => {};
let fn2: Fn<unknown> = fn1; // contravariance
```

> ğŸ‘‰ This is tricky, but shows up inÂ event handler typesÂ andÂ callback design.
>

## 9. How does TypeScript support Template Literal Types?

**Answer:**

They let you buildÂ **string types dynamically**.

**Example:**

```javascript
type EventName<T extends string> = `on${Capitalize<T>}`;

type Click = EventName<"click">;   // "onClick"
type Change = EventName<"change">; // "onChange"
```

ğŸ‘‰ Used inÂ **React event typings**,Â **framework APIs**, andÂ **string-based DSLs**.

## 10. Explain Declaration Merging.

**Answer:**

In TypeScript, multiple declarations of the same name are merged into one.

**Example:**

```javascript
interface User { id: number; }
interface User { name: string; }

const u: User = { id: 1, name: "Alex" };
```

ğŸ‘‰ This is heavily used inÂ **extending library types**Â (like Express request objects).
